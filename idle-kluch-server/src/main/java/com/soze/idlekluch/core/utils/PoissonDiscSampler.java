package com.soze.idlekluch.core.utils;

import com.soze.idlekluch.kingdom.entity.Kingdom;

import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * Implements the Poisson-Disc Sampling algorithm (see <a href="http://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf">Link</a>).
 * <p>
 * This class can be used for many purposes, but it was first created for choosing next {@link Kingdom} starting position.
 */
public final class PoissonDiscSampler {

  /**
   * Each existing point is tried this amount of times to generate next
   * point. After this number, another random point is chosen around which next suitable
   * spots will be generated.
   */
  private static final int ATTEMPTS_BEFORE_REJECTION = 5;

  private final Set<Point> currentPoints;

  /**
   * Minimum distance between points generated by this algorithm.
   */
  private final int minimumDistance;

  /**
   * Creates a new PoissonDiscSampler with given points and a minimum distance between points for
   * newly generated points. The existing points don't have to be within minimumDistance of each other.
   */
  public PoissonDiscSampler(final List<Point> currentPoints, final int minimumDistance) {
    this.currentPoints = new HashSet<>(Objects.requireNonNull(currentPoints));
    this.minimumDistance = minimumDistance;
  }

  public List<Point> getCurrentPoints() {
    return new ArrayList<>(currentPoints);
  }

  /**
   * Finds the next point to place. Adds the point to the list of current points.
   * This algorithm does not bound the search space, so a result is guaranteed.
   */
  public Point nextPoint() {
    //1. No need to run the algorithm for the first point
    if (currentPoints.isEmpty()) {
      final Point firstPoint = new Point(0, 0);
      currentPoints.add(firstPoint);
      return firstPoint;
    }

    //2. Obtain a list of points, so we can randomly find one to check
    final List<Point> pointList = new ArrayList<>(currentPoints);
    //3. Start searching for the next point.
    Point nextPoint = null;
    while (nextPoint == null) {
      //4. Check if we even have points left to check, if not, repopulate the list
      if(pointList.isEmpty()) {
        pointList.addAll(currentPoints);
      }

      //5. Find a random index of a tile to check and the tile itself
      final int tileIndex = CommonUtils.randomNumber(0, pointList.size() - 1);
      final Point pointToCheck = pointList.get(tileIndex);

      //6. Keep generating random points around the found point to check.
      int attempts = 0;
      while (attempts < ATTEMPTS_BEFORE_REJECTION) {
        final int distanceFromPoint = CommonUtils.randomNumber(minimumDistance, minimumDistance * 2);
        final int xDirection = CommonUtils.randomNumber(-1, 1);
        final int yDirection = CommonUtils.randomNumber(-1, 1);
        final int x = pointToCheck.x + (distanceFromPoint * xDirection);
        final int y = pointToCheck.y + (distanceFromPoint * yDirection);

        //6. Check if given point is at least minimumDistance from all other points.
        if (isMinimumDistanceAwayFromAllPoints(x, y)) {
          nextPoint = new Point(x, y);
          break;
        } else {
          ++attempts;
        }
      }

      //7. A valid point was not found around pointToCheck, remove it
      if(nextPoint == null) {
        pointList.remove(tileIndex);
      }
    }

    //8. Found it!
    currentPoints.add(nextPoint);
    return nextPoint;
  }

  /**
   * Checks whether a point described by x, y is at least minimumDistance
   * from all existing points.
   */
  private boolean isMinimumDistanceAwayFromAllPoints(final int x, final int y) {
    //1. Find the bounds of our check
    final int xMin = x - minimumDistance;
    final int yMin = y - minimumDistance;
    final int xMax = x + minimumDistance;
    final int yMax = y + minimumDistance;

    //2. Create a point that we will mutate, no need to create it hundreds of times
    final Point point = new Point(0, 0);
    //3. Search through the bounds to find a tile
    for(int i = xMin; i < xMax; i++) {
      for(int j = yMin; j < yMax; j++) {
        point.x = i;
        point.y = j;
        if(currentPoints.contains(point)) {
          //4. There is a tile that is too close
          return false;
        }
      }
    }
    //4. There isn't a tile that is too close
    return true;
  }

}
