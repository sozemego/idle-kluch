package com.soze.idlekluch.utils;

import com.soze.idlekluch.kingdom.entity.Kingdom;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


/**
 * Implements the Poisson-Disc Sampling algorithm (see <a href="http://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf">Link</a>).
 *
 * This class can be used for many purposes, but it was first created for choosing next {@link Kingdom} starting position.
 *
 */
public final class PoissonDiscSampler {

  /**
   * Each existing point is tried this amount of times to generate next
   * point. After this number, another random point is chosen around which next suitable
   * spots will be generated.
   */
  private static final int ATTEMPTS_BEFORE_REJECTION = 30;

  private final List<Point> currentPoints;

  /**
   * Minimum distance between points generated by this algorithm.
   */
  private final int minimumDistance;

  /**
   * Creates a new PoissonDiscSampler with given points and a minimum distance between points for
   * newly generated points. The existing points don't have to be within minimumDistance of each other.
   */
  public PoissonDiscSampler(final List<Point> currentPoints, final int minimumDistance) {
    this.currentPoints = new ArrayList<>(Objects.requireNonNull(currentPoints));
    this.minimumDistance = minimumDistance;
  }

  public List<Point> getCurrentPoints() {
    return new ArrayList<>(currentPoints);
  }

  /**
   * Finds the next point to place. Adds the point to the list of current points.
   * This algorithm does not bound the search space, so a result is guaranteed.
   */
  public Point nextPoint() {
    //1. No need to run the algorithm for the first point
    if (currentPoints.isEmpty()) {
      final Point firstPoint = new Point(0, 0);
      currentPoints.add(firstPoint);
      return firstPoint;
    }

    //2. Start searching for the next point.

    Point nextPoint = null;
    while (nextPoint == null) {
      //3. Get a random point from existing ones.
      Optional<Point> pointToCheckOptional = CommonUtils.getRandomElement(currentPoints);
      if(!pointToCheckOptional.isPresent()) {
        throw new IllegalStateException("There has to be a point to check, this exception should never be thrown!");
      }
      final Point pointToCheck = pointToCheckOptional.get();
      //4. Keep generating random points around the found point to check.
      int attempts = 0;
      while(attempts < ATTEMPTS_BEFORE_REJECTION) {
        final double distanceFromPoint = CommonUtils.randomNumber(minimumDistance, minimumDistance * 2);
        final double angle = CommonUtils.randomNumber(0d, 360d);
        final int x = (int)(distanceFromPoint * Math.cos(angle)) + pointToCheck.x;
        final int y = (int)(distanceFromPoint * Math.sin(angle)) + pointToCheck.y;

        //5. Check if given point is at least minimumDistance from all other points.
        if(isMinimumDistanceAwayFromAllPoints(x, y)) {
          nextPoint = new Point(x, y);
        } else {
          ++attempts;
        }
      }

    }

    currentPoints.add(nextPoint);
    return nextPoint;
  }

  /**
   * Checks whether a point described by x, y is at least minimumDistance
   * from all existing points.
   */
  private boolean isMinimumDistanceAwayFromAllPoints(final int x, final int y) {
    for(final Point point: currentPoints) {
      final double distance = Math.hypot(x - point.x, y - point.y);
      if(distance < minimumDistance) {
        return false;
      }
    }
    return true;
  }

}
